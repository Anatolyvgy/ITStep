/*Использование указателей в функциях, инициализация, функция swap.
Указатели нужны для того, чтобы оперировать большим количеством 
значений в наших функциях, чтобы возвращать значения, полученные
внутри функции.
Связь указателей и массивов. Арифметические операции над указателями.*/

/**Переменная указателя всегда int(4 байта), потому что она всегда
хранит адрес, а это целочисленное число, хоть и в шестнадцатеричном
формате*/


/**Создать 3 переменных, 3 указателя различных типов, вывести на 
экран адреса, которые хранятся в этих указателях*/

//#include<stdio.h>;
//int main()
//{
//	int a;
//	char b;
//	float c;
//	int* pa = &a;
//	char* pb = &b;
//	float* pc = &c;
//
//	printf("&pa: 0x%p\n", pa);
//	printf("&pb: 0x%p\n", pb);
//	printf("&pc: 0x%p\n", pc);
//
//	return 0;
//}

/**поменять местами значения, хранящиеся по указателю pa и pc*/

//#include<stdio.h>;
//int main()
//{
//	int a;
//	char b;
//	float c;
//	int* pa = &a;
//	char* pb = &b;
//	float* pc = &c;
//
//	int buff = 0;
//	buff = *pa;
//	*pa = *pc;
//	*pc = buff;
//
//	printf("&pa: 0x%p\n", pa);
//	printf("&pb: 0x%p\n", pb);
//	printf("&pc: 0x%p\n", pc);
//	return 0;
//}

/**сделать так, чтобы указатели смотрели на противоположные переменнные 25.00*/

//#include<stdio.h>;
//int main()
//{
//	int a;	
//	float c;
//	int* pa = &a;	
//	float* pc = &c;
//
//	printf("&pa: 0x%p\n", pa);
//	//printf("&pb: 0x%p\n", pb);
//	printf("&pc: 0x%p\n", pc);
//
//	int* pbuff = pa;	
//	pa = pc;
//	pc = *pbuff;
//
//	printf("&pa: 0x%p\n", pa);	
//	printf("&pc: 0x%p\n", pc);
//
//	return 0;
//}

/** void* - это указатель на непонятно какой тип. Если нам нужно поменять указатели,
а мы заранее не знаем на какой тип данных они ссылаются, мы можем их перекинуть
через void* указатель. Но для того, чтобы достать из него значение *boof, нам нужно
будет сделать приведение нужного типа

int main()
{
int a = 10;
float b = 5.15;
int* pa = &a;
float* pb = &b;
void* buff;

buff = pa;
pa = pb;
pb = buff;
printf("%i\n", *(int*)buff);

buff = pa;
pa = pb;
pb = buff;
printf("%f\n", *(float*)buff);

return 0;
}
*/

/*Домашка. Рекурсия с указателями.
В задании не помечен один момент. Для того чтобы сделать рекурсию,
нам нужно число, до которого мы будем делать рекурсию. Идея состоит в том, 
что результат нужно вернуть не через return, а через указатель - через
*result, являющийся аргументом функции. 1.22 = 82  
__________________________________________________________
Нам нужна рекурсия. Рекурсия - это просто вызов функции. Факториал будет
возвращаться не через возвращаемое значение, он будет возвращаться через
указатель, который будет передаваться в функцию. Соответственно нам нужен
указатель для результата. Результат будет целочисленным, поэтому это 
будет int result и result мы будем передавать через адрес, т.е. в функцию
мы передаем  адрес нашей переменной. И нам еще нужно число, которое мы будем
искать int const n = 3. (83.39)
*/

//
//#include<stdio.h>
//#include<stdlib.h>
//#include<stdbool.h>
//
//void getFactorial(int n, int* result);
//
//int main()
//{
//
//
//	int const n = 4;
//	int result = 1;
//	getFactorial(n, &result);
//
//	printf("result = %i", result);
//
//	return 0;
//}


/*Реализация. Факториал вызывает сам себя с n - 1. И туда надо передать result.
Т.к. result это и есть указатель, к нему в начале ничего приписывать не надо,
никаких &. У нас уже есть указатель, в котором будет храниться результат. В 
результат мы записываем n * значение результата после выхода из этой функции.
Еще нам нужно условие выхода из функции.*/
//void getFactorial(int n, int* result)
//{
//	if (n < 2)
//	{
//		return;
//	}
//
//	getFactorial(n - 1, result);
//	*result = n * (*result);
//}
//
/*________________________________________________________________________*/

//#include<stdio.h>
//
//int main()
//{
//	int* pI = NULL;
//	int i = 100;
//	for (pI = &i; pI < &i + 4; pI++)
//	{
//		printf("0x%p\n", pI);
//	}
//
//	return 0;
//}

/*________________________________________________________________

Написать функцию swap, только через указатели. Т.е. функция должна 
переставить 2 переменные через их указатели. Сделать защиту от нулевого 
указателя  98.00
119.30*/

#include<stdio.h>
#include<stdlib.h>
#include<stdbool.h>

void swap(int* a, int* b);

int main()
{
	//int* a = NULL;
	//int* b = NULL;

	int a = 7;
	int b = 5;

	printf("a = %i\n", a);
	printf("b = %i\n", b);

	//swap(NULL, NULL);
	swap(&a, &b);
 	
	printf("a = %i\n", a);
	printf("b = %i\n", b);

	return 0;
}

//можно так
//void swap(int* a, int* b)
//{
//	if (a == 0x00000000 || b == 0x00000000)/*на случай если 
//										   пользователь введет NULL
//										   в качестве аргумента*/
//	{
//		printf("Error\n");
//	}
//
//	int buff = *a;
//	*a = *b;
//	*b = buff;	
//}


//или так
void swap(int* a, int* b)
{
	if (a == NULL || b == NULL)/*на случай если
										   пользователь введет NULL
										   в качестве аргумента*/
	{
		printf("Error\n");
		return;
	}

	int buff = *a;
	*a = *b;
	*b = buff;
}
/** вывод: всегда нужно смотреть, проинициализированы ли 
переменные и указатели и чем они проинициализированы,
потому что студия не поможет. Инициализировать указатели 
можно и нужно NULLом*/

/** ________________________________  Тема
Связь указателей и массивов. Арифметические операции над указателями.
Имя массива является указателем на его 0 элемент*/

#include<stdio.h>
#include<stdlib.h>
#include<stdbool.h>

int main()
{
	int i[3];
	int* pi = &i;

	printf("i = %p\n", i);//имя массива является адресом 0 элемента массива
	printf("&i = %p\n", &i);//поэтому эти четыре записи эквивалентны
	printf("pi = %p\n", pi);
	printf("&i[0] = %p\n", &i[0]);

	/*************  адресация ячеек 145.40
	&i[0] - 0x100 byte
	int - 0x100 0x101 0x102 0x103
	&i[1] - 0x104 byte
	&i[2] - 0x108 byte
	&i[3] - 0x112 byte
	**************************************/
	
	/********************************************************************************/
	
	int main()
{
	char arrayC[5];	
	for (int i = 0; i < 5; i++)
	{
		printf("&arrayC[%i]: %p\n", i, &arrayC[i]);
	}
	/*************  адресация ячеек 
	&arrayC[0] - 0x100 byte
	char - 0x100 1 byte
	&arrayC[1] - 0x100 byte
	&arrayC[2] - 0x101 byte
	&arrayC[3] - 0x102 byte
	**************************************/
	return 0;
}

/***********************************************************************************/

int array[5];
	int* last = &array[4];//указатель на последний элемент массива
	for (int* i = array; i != last; i++)//пока адрес, хранящийся в i,
		//не равен адресу последнего элемента, инкрементируем i - адрес
	{
		printf("i[%i]: %p\n", i, i);//выводим адрес 
	}
	
/*******************************************************************************/
	
int main()
{
	int array[5] = { 2, 4, 7, 9, 15 };
	
	printf("%p\n", array);//адрес 0 элемента

	int* a1 = &array[1];//адрес 1 элемента

	printf("%p\n", a1);//адрес 1 элемента

	printf("%p\n", array + 1);//адрес 1 элемента
	printf("%p\n", array + 2);//адрес 2 элемента
	printf("%p\n", array + 3);//адрес 3 элемента
	printf("%p\n", array + 4);//адрес 4 элемента
	printf("\n");
	
	// *array то же самое, что и array[0] - значение элемента

	printf("%i\n", *array + 1);//значение 0 элемента + 1
	printf("%i\n", *array + 2);//значение 0 элемента + 2
	printf("%i\n", *array + 3);//значение 0 элемента + 3
	printf("%i\n", *array + 4);//значение 0 элемента + 4
	printf("\n");

	printf("%i\n", *(array + 1));//значение 1 элемента
	printf("%i\n", *(array + 2));//значение 2 элемента
	printf("%i\n", *(array + 3));//значение 3 элемента
	printf("%i\n", *(array + 4));//значение 4 элемента
	printf("\n");

	for (int i = 0; i < 5; i++)
	{
		printf("%i\n", *(array + i));
	}

	return 0;
}	
